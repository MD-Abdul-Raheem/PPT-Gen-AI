import PptxGenJS from 'pptxgenjs';
import { PresentationData, SlideLayout, Theme, TransitionType } from '../types';

// Helper to convert rgb string to hex (without #)
const rgbToHex = (string: string | null | undefined): string | undefined => {
  if (!string || string === 'transparent' || string === 'inherit') return undefined;
  if (string.startsWith('#')) return string.substring(1);
  const rgb = string.match(/\d+/g);
  if (!rgb || rgb.length < 3) return undefined;
  const hex = ((1 << 24) + (Number(rgb[0]) << 16) + (Number(rgb[1]) << 8) + Number(rgb[2])).toString(16).slice(1).toUpperCase();
  return hex;
};

/**
 * Parses a HTML string into PptxGenJS Text Items options.
 * Supports <b>, <strong>, <i>, <em>, <u>, <s>, <font color>, style attrs.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const parseHtmlToPptxTextItems = (html: string, baseOptions: any): any[] => {
    const div = document.createElement('div');
    div.innerHTML = html;
    
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const items: any[] = [];

    // Recursive function to traverse DOM nodes
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const traverse = (node: Node, currentStyles: any) => {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            if (text) {
                items.push({
                    text: text,
                    options: { ...baseOptions, ...currentStyles }
                });
            }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node as HTMLElement;
            // Clone styles
            const newStyles = { ...currentStyles };
            
            // Check tags and update styles
            const tagName = element.tagName.toUpperCase();
            const style = element.style;

            // Bold
            if (tagName === 'B' || tagName === 'STRONG' || style.fontWeight === 'bold' || parseInt(style.fontWeight || '0') >= 700) {
                newStyles.bold = true;
            }
            // Italic
            if (tagName === 'I' || tagName === 'EM' || style.fontStyle === 'italic') {
                newStyles.italic = true;
            }
            // Underline
            if (tagName === 'U' || style.textDecoration.includes('underline')) {
                newStyles.underline = true;
            }
            // Strikethrough
            if (tagName === 'S' || tagName === 'STRIKE' || tagName === 'DEL' || style.textDecoration.includes('line-through')) {
                newStyles.strike = true;
            }
            // Color
            if (style.color) {
                const hex = rgbToHex(style.color);
                if (hex) newStyles.color = hex;
            }
            if (tagName === 'FONT' && element.getAttribute('color')) {
                 const colorAttr = element.getAttribute('color');
                 if (colorAttr) {
                     const hex = rgbToHex(colorAttr);
                     if (hex) newStyles.color = hex;
                 }
            }
            
            // Traverse children
            element.childNodes.forEach(child => traverse(child, newStyles));
        }
    };

    div.childNodes.forEach(child => traverse(child, {}));
    
    if (items.length === 0) {
        return [{ text: '', options: baseOptions }];
    }

    return items;
};

export const generatePptx = async (
    presentation: PresentationData, 
    theme: Theme, 
    defaultTransition: TransitionType = 'fade',
    textEntranceAnimation: string = 'fadeIn'
) => {
  const pres = new PptxGenJS();

  // Set Metadata
  pres.title = presentation.title;
  pres.subject = presentation.subtitle || 'Generated by SlideGen AI';
  pres.author = 'SlideGen AI';

  // Define Layouts/Masters based on Theme
  pres.defineSlideMaster({
    title: 'MASTER_SLIDE',
    background: { color: theme.colors.background },
    objects: [
      {
        rect: { x: 0, y: '90%', w: '100%', h: '10%', fill: { color: theme.colors.accent } },
      },
      {
        text: {
            text: 'Generated by SlideGen AI',
            options: { x: 0.5, y: '92%', fontSize: 10, color: theme.colors.secondary }
        }
      }
    ],
    slideNumber: { x: '95%', y: '92%', fontSize: 10, color: theme.colors.secondary }
  });

  // 1. Title Slide
  const titleSlide = pres.addSlide({ masterName: 'MASTER_SLIDE' });
  const titleSlideImage = presentation.slides[0]?.imageData;

  if (titleSlideImage) {
      // Image on Right
      titleSlide.addImage({
          data: titleSlideImage,
          x: '55%',
          y: '20%',
          w: '40%',
          h: '60%',
          sizing: { type: 'contain', w: '40%', h: '60%' }
      });
      // Text on Left
      titleSlide.addText(presentation.title, {
        x: '5%',
        y: '35%',
        w: '45%',
        h: 1,
        fontSize: 40,
        bold: true,
        color: theme.colors.text,
        align: 'left',
        fontFace: theme.fonts.heading,
      });
      if (presentation.subtitle) {
        titleSlide.addText(presentation.subtitle, {
          x: '5%',
          y: '50%',
          w: '45%',
          h: 0.5,
          fontSize: 20,
          color: theme.colors.primary,
          align: 'left',
          fontFace: theme.fonts.body,
        });
      }
  } else {
      // Centered (Fallback)
      titleSlide.addText(presentation.title, {
        x: '10%',
        y: '40%',
        w: '80%',
        h: 1,
        fontSize: 44,
        bold: true,
        color: theme.colors.text,
        align: 'center',
        fontFace: theme.fonts.heading,
      });

      if (presentation.subtitle) {
        titleSlide.addText(presentation.subtitle, {
          x: '15%',
          y: '55%',
          w: '70%',
          h: 0.5,
          fontSize: 24,
          color: theme.colors.primary,
          align: 'center',
          fontFace: theme.fonts.body,
        });
      }
  }

  if (defaultTransition && defaultTransition !== 'none') {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (titleSlide as any).transition = { type: defaultTransition, duration: 1000 };
  }

  // 2. Content Slides
  presentation.slides.forEach((slide) => {
    // Skip creating a new slide for index 0 if we assume it was the title slide created above.
    // However, the `slides` array usually includes the title slide as the first element in our data model.
    // Let's assume we treat the first slide in `slides` array as the specific title slide content above
    // and only iterate from index 1 for others, OR just allow the loop to handle all and ignore special title handling above.
    // BUT the request is to have a specific Title Slide logic. 
    // Current app logic: title slide is generated manually above.
    // We should skip the first slide in the loop if it's the title slide, but the loop iterates `presentation.slides`.
    // Let's filter or check index.
    
    // NOTE: The `presentation.slides` from geminiService includes the title slide as the first item.
    // We generated the Title Slide manually above using `presentation.title/subtitle`.
    // Let's assume the loop handles the *rest*, or we just overwrite.
    // To match previous logic, let's assume `presentation.slides` contains everything, 
    // but the manual title slide creation above was a "Cover" slide using the meta title.
    // The first slide in `presentation.slides` is usually the "Title Slide" type.
    // We will just process ALL slides in the loop, but for the first one (Title type), we might skip it 
    // IF we consider the cover created above as THE title slide.
    // Let's assume we create a *new* slide for every slide in the array.
    // If the loop processes a 'title' type slide, it's essentially a duplicate of the cover if we aren't careful.
    // Let's just create slides from the array. The cover slide above is good, let's treat it as the "Cover".
    // We will iterate all slides.
    
    const pptSlide = pres.addSlide({ masterName: 'MASTER_SLIDE' });
    
    // Slide Title
    pptSlide.addText(slide.title, {
      x: 0.5,
      y: 0.4,
      w: '90%',
      h: 0.6,
      fontSize: 32,
      bold: true,
      color: theme.colors.primary,
      fontFace: theme.fonts.heading,
      fill: { color: theme.colors.background } // ensure background covers anything behind
    });

    const hasImage = !!slide.imageData;
    const contentWidth = hasImage ? '55%' : '90%';

    // Content
    if (slide.type === SlideLayout.CONTENT || slide.type === SlideLayout.SECTION || slide.type === SlideLayout.CONCLUSION) {
        // Image placement
        if (hasImage && slide.imageData) {
            pptSlide.addImage({
                data: slide.imageData,
                x: '62%',
                y: '1.4', // inches approx
                w: '33%',
                h: '4.5', // inches approx
                sizing: { type: 'contain', w: '33%', h: '4.5' }
            });
        }

        if (slide.content && slide.content.length > 0) {
            
            const baseOptions = { 
                fontSize: 18, 
                color: theme.colors.text, 
                bullet: true, 
                breakLine: true,
                paraSpaceAfter: 10,
                fontFace: theme.fonts.body
            };
            
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const allItems: any[] = [];

            slide.content.forEach((point) => {
                const segments = parseHtmlToPptxTextItems(point, baseOptions);
                if (segments.length > 0) {
                    segments[0].options.bullet = true;
                    segments[segments.length - 1].options.breakLine = true;
                }
                allItems.push(...segments);
            });
            
            if (allItems.length > 0) {
                allItems[allItems.length - 1].options.breakLine = false;
            }

            pptSlide.addText(allItems, {
                x: 0.5,
                y: 1.4,
                w: contentWidth,
                h: '75%',
                align: 'left',
                fontFace: theme.fonts.body,
                valign: 'top',
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                animation: { type: textEntranceAnimation, duration: 1000 } as any
            });
        }
    } else if (slide.type === SlideLayout.TITLE) {
       // Re-implementing title slide logic within the loop (e.g. for Section Headers)
       // Center align everything
        if (hasImage && slide.imageData) {
             pptSlide.addImage({
                data: slide.imageData,
                x: '55%',
                y: '25%',
                w: '40%',
                h: '50%',
                sizing: { type: 'contain', w: '40%', h: '50%' }
            });
            
            if (slide.content && slide.content.length > 0) {
                const baseOptions = { fontSize: 20, color: theme.colors.secondary, align: 'left', breakLine: true };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const allItems: any[] = [];
                slide.content.forEach((point) => {
                    const segments = parseHtmlToPptxTextItems(point, baseOptions);
                    if (segments.length > 0) segments[segments.length - 1].options.breakLine = true;
                    allItems.push(...segments);
                });
                if (allItems.length > 0) allItems[allItems.length - 1].options.breakLine = false;

                pptSlide.addText(allItems, {
                    x: '5%',
                    y: 2,
                    w: '45%',
                    align: 'left',
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    animation: { type: textEntranceAnimation, duration: 1000 } as any
                });
            }

        } else {
             // Centered Text
             if (slide.content && slide.content.length > 0) {
                 const baseOptions = { fontSize: 20, color: theme.colors.secondary, align: 'center', breakLine: true };
                 // eslint-disable-next-line @typescript-eslint/no-explicit-any
                 const allItems: any[] = [];
                 slide.content.forEach((point) => {
                    const segments = parseHtmlToPptxTextItems(point, baseOptions);
                    if (segments.length > 0) segments[segments.length - 1].options.breakLine = true;
                    allItems.push(...segments);
                 });
                 if (allItems.length > 0) allItems[allItems.length - 1].options.breakLine = false;
    
                pptSlide.addText(allItems, {
                    x: 1,
                    y: 2,
                    w: '80%',
                    align: 'center',
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    animation: { type: textEntranceAnimation, duration: 1000 } as any
                });
            }
        }
    }

    const transitionType = slide.transition || defaultTransition;
    if (transitionType && transitionType !== 'none') {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (pptSlide as any).transition = { type: transitionType, duration: 1000 };
    }
  });

  await pres.writeFile({ fileName: `${presentation.title.replace(/[^a-z0-9]/gi, '_').substring(0, 20)}.pptx` });
};